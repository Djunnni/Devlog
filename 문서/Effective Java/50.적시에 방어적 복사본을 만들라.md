## 50.적시에 방어적 복사본을 만들라

자바는 안전한 언어다. 네이티브 메서드를 사용하지 않다보니 C,C++ 같이 안전하지 않은 언어에서 흔히 보는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.

자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다. 메모리 전체를 하나의 거대한 배열로 다루는 언어에서는 누릴 수 없는 강점이다.

자바라고해서 다른 클래스로부터의 침범을 아무런 노력없이 다 막을 수 있는 건 아니다.

**클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.**

실제로도 악의적인 의도를 가지고 있는 사람들이 시스템의 보안을 뚫으려는 시도가 늘고 있다. 평범한 프로그래머도 순전히 실수로 여러분의 클래스를 오작동하게 만들 수 있다.

충분히 시간을 투자해서 클라이언트로부터 클래스를 보호하는 데 쓰자!!
> (me) 실제로도 지켜져야할 부분이라고 생각한다. 악의적인 URL 경로 조작 및 데이터 조작으로 여러 시도를 하는 경우가 많아지고 있다. 그렇기에 서버에서는 이 부분까지 고려해야한다.

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하다.

하지만 주의를 기울이지 않으면 자기도 모르게 내부를 수정하도록 허락하는 경우가 생긴다. 흔히 발생하는데 코드를 봐보자

```java
public final class Period {
    private final Date start, end;

    public Period(Date start,Date end) {
        if(start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        }
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }
    public Date end() {
        return end;
    }
}
```

얼핏 클래스는 불변처럼 보이고, 시작 시각이 종료 시각보다 늦을 수 없다는 불변식이 무리없이 지켜질 것 같다. 하지만 Date가 가변이라는 사실을 이용하면 어렵지않게 불변식을 깰 수 있다.

```java 
// 인스턴스 Period 내부를 공격해보자
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(end) // 집어넣은 객체를 날짜를 수정한다.

```

다행히 자바 8 이후로는 쉽게 해결할 수 있다. Date 대신 불변인 Instant를 사용하면 된다. (ex. LocalDateTime, ZonedDateTime)

Date는 낡은 API이니 새로운 코드를 작성할 때는 더이상 사용하면 안된다.

외부 공격으로부터 Period인스턴스의 내부를 보호하려면 생성자를 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.

```java
public Period(Date start,Date end) {
        if(start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        }
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
    }

```

새로 작성한 생성자를 사용하면 앞서의 공격은 더이상 Period에 위협이 되지 않는다.

**매개변수의 유효성을 검사(아이템49)하기전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목하자.**

```java
public Period(Date start,Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if(this.start.compareTo(this.end) > 0) {
        throw new IllegalArgumentException(this.start + "가 " + this.end + "보다 늦다.");
    }
}
```
순서가 부자연스러워 보이겠지만 반드시 이렇게 작성해야한다.

멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.

방어적 복사를 매개변수 유효성 검사를 검사시점, 사용시점 공격 혹은 영어표기를 줄여 TOCTOU 공격이라 부른다.

**방어적 복사에 Date의 clone 메서드를 사용하지 않은 점에도 주목하자!**

Date는 final이 아니므로 clone이 Date를 정의한 게 아닐 수 있다. 즉, clone이 약의 역할 울 가진 하위 클래스의 인스턴스를 반환할 수 있다.

예컨데 이 하위 클래스는 start와 end 필드의 참조를 private 정적 리스트에 담아뒀다가 공격자에게 이 리스트에 접근하는 길을 열어줄 수 있다.

결국 공격자에게 Period인스턴스 자체를 송두리째 맡기는 꼴이 된다. 이러한 공격을 막기위해서 **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때, clone를 사용해서는 안된다.**

두번째 공격을 막아내려면 단순히 접근자가 가변필드의 방어적 복사본을 반환하면 된다.

```java
  public Date start() {
        return new Date(start.getTime());
    }
    public Date end() {
        return new Date(end.getTime());
    }
```
새로운 접근자까지 갖추면 Period는 완벽한 불변으로 거듭난다. 아무리 악의적인 혹은 부주의한 프로그래머라도 시작 시간이 종료 시각보다 나중일 수 없다는 불변식을 위배할 방법이 없다.

(네이티브 메서드나 리플렉션 같이 언어외적인 수단을 동원하면 뚤릴 순 있다.)

### 유의할 점

1. 매개변수를 방어적으로 복사하는 것이 불변 객체를 만들기 위해서만 아니다. 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는 지를 생각해야 한다.

    변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할 지를 따져보자.

2. 내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 이유도 마찬가지다. 여러분의 클래스가 불변이든 가변이든, 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야한다. 

길이가 1이상은 배열은 무조건 가변적이다.

내부에서 사용하는 배열을 클라이언트에 반환할 때는 항상 방어적 복사를 수행해야 한다.

3. 방어적 복사에는 성능 저하가 따르고 또 항상 쓸 수 있는 것도 아니다.

호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.

    다른 패키지에서 사용한다고 해서 넘겨받은 가변 매개변수를 항상 방어적으로 복사해 저장해야 하는 것은 아니다.
    메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 이전함을 뜻하기도 한다.

    통제권을 이전하는 메서드를 호출하는 클라이언트는 해당 객체를 더 이상 직접 수정하는 일이 없다고 약속해야한다.

    클라이언트가 건네주는 가변 객체의 통제권을 넘겨 받는다고 기대ㄷ하는 메서드나 생성자에서도 그 사실을 확실한 문서로 기재해야한다.

4. 통제권을 넘겨받기로 한 메서드나 생성자를 가진 클래스들은 악의적인 클라이언트의 공격에 취약하다.

    방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한 될 때, 한정해야한다.

