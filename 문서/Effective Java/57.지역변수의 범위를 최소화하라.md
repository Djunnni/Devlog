## 지역변수의 범위를 최소화하라

"클래스와 멤버의 접근 권한을 최소화하라" [아이템15]와 취지가 비슷하다.
지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

C와 같이 역사가 깊은 프로그래밍 언어중에는 지역변수를 코드 블록의 첫머리에 선언하는 경우가 많고, 이방식을 여전히 습관처럼 따르는 프로그래머도 있다.

하지만 자바에서는 문장을 선언할 수 있는 곳이면 어디서든 변수를 선언할 수 있다.(C99 표준부터 C도 문장을 선언할 수 있는 곳이면 어디서든 가능하다.)

**지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.**

사용하려면 멀었는데 미리 선언해두면 코드가 어수선해져 가독성이 떨어진다. 실제로 변수를 사용하는 시점엔 타입과 초기값이 생각이 안날 수 있다.

지역변수를 생각없이 선언하다보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴뒤에도 여전히 살아있게 되기 쉽다.

지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날 때까지이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아있게 된다.

실수로 의도한 범위 앞 혹은 뒤에서 그 변수를 사용하면 끔찍한 결과로 이어질 수 있다.

또한 **거의 모든 지역변수는 선언과 동시에 초기화해야 한다.** 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다. try-catch문은 이 규칙에서 예외다.
> (me)선언과 동시에 초기화를 하는데에 동의한다. 코드작성 시, 구분이 되면 더 길어짐은 기본이고 놓칠 수 있다는 생각이 든다.

변수를 초기화 하는 표현식에서 검사 예외를 던질 가능성이 있다면 try블록 안에서 초기화해야 한다. 한편, 변수값을 try블록 바깥에서도 사용해야한다면(비록 정확히 초기화하진 못하더라도) try블록 앞에서 선언해야한다.

반복문은 독특한 방식으로 변수 범위를 최소화해준다. 예전의 for형태든 새로운 for-each형태든 반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다.

따라서 반복변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while보다 for문을 쓰는 편이 좋다.

```java
for(Element e : c) {
    ... e로 무언가 하기
}

반복자를 써야하는 경우
for(Iterator<Element> i = c.iterator(); i.hasNext();) {
    Element e = i.next();
    ... // e와 i로 무언가 하기
}
```

두 while문을 보면 앞서 for문이 더 나은 이유를 알 수 있다. 다음코드에도 버그가 하나 숨어있다.

```java
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
    doSomething(i.next());
}

...

Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) {    // 버그
    doSomethingElse(i2.next())
}
```

두 번째 while문에는 복사해 붙여넣기 오류가 있다. 새로운 반복 변수 i2를 초기화했지만, 실수로 이전 while문에서 쓴 i를 다시 쓴 것이다. 불행히도 i의 유효범위는 아직 끝나지 않아 컴파일도 되고 실행시 예외도 던지지 않는다.
하지만 2번째 while문은 순회없이 바로 끝난다. 프로그램 오류가 겉으로 드러나지 않으니 오랜 기간 발견되지 않을 수 있다.
> (me) 충분히 있을 수 있는 경우다. 이 경우에 대해서 개발자나 리뷰어가 잘 봐줘야 하겠지만 TC를 작성하면 어느정도 해소될 수 있는 부분이라는 생각이 든다.

(for-each를 포함한) for문을 사용하면 이런 복사해 붙여넣기 오류를 컴파일 타임에 잡아준다. 첫번째 반복문이 사용한 원소와 반복자의 유효 범위가 반복문 종료와 함께 끝나기 때문이다. 다음은 전통적인 for문에서의 상황을 보여준다.

```java
for(Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
}
// i를 찾을 수 없다는 컴파일 오류 발생
for(Iterator<Element> i2 = c2.iterator(); i.hasNext();) {
    Element e2 = i2.next();
}
```

for문이 복사해 붙여넣기 오류를 줄여주는 이유는 또 있다. 변수 유효 범위가 for문 범위와 일치해 똑같은 이름의 변수를 여러 반복문에서 써도 아무런 영향을 주지 않는다. 사실 이렇게 쓰는게 더 세련되기까지 하다.

```java
for(int i = 0, n = expensiveComputation(); i < n; i++) {
    ...
}
```

이 관용구에서 주목할 부분은 범위가 정확히 일치하는 두 반복 변수 i와 n이다. 반복 여부를 결정짓는 변수 i의 한곗값을 변수 n에 저장하여, 반복때마다 다시 계산해야하는 비용을 없앴다. 같은 값을 반환하는 메서드를 매번 호출한다면 이 관용구를 사용하기 바란다.
> (me) 좀 신선하게 다가왔는데 지금까지 배열의 길이나 리스트 길이 등 다양하게 조건문에서 검사를 하고 있었다. 그때마다 계산 비용이 발생함을 알게 됐고 다음부터는 위 방식을 사용하기로 마음먹었다.

지역변수 범위를 최소화하는 마지막 방법은 **메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.** 한 메서드는 여러가지 기능을 처리한다면 그중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있을 것이다. 해결책은 간단하다.

단순히 메서드를 기능별로 쪼개면 된다.

> (me) 동의한다. 다만 함수가 너무 쪼개지는 것은 오히려 더 불편함을 줄 수 있다고 생각한다. 여건에 맞게 코드의 가독성을 크게 해치지 않는다면 나는 2~3가지 정도는 하나의 함수에서 일관되게 처리해도 괜찮다고 생각한다. 단, 언제든지 분리는 진행할 수 있도록 대비한다.