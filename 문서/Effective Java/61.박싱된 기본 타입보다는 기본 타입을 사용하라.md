## 박싱된 기본 타입보다는 기본 타입을 사용하라

자바의 데이터 타입

1) 기본 타입 
    - ex) int, boolean, long, double, char, float, byte, short
2) 참조 타입
    - ex) Integer, Boolean, Long, Double, Char, Float, Byte, Short, String, List 등

> 기본타입에 대응하는 박싱된 기본타입은 앞에 대문자가 들어가고 부족한 String이 더 첨부된다.

### 기본타입과 박싱된 기본타입의 차이점

오토박싱과 언오토박싱 덕분에 두 타입을 구분하지 않고 사용이 가능해졌다. 하지만 **차이점**이 중요하다.

1) 기본타입은 값만 가지고 있으나 박싱된 기본 타입은 값에 더해 식별성을 가지고 있다.
    - 두 인스턴스의 값이 같으나 서로 다르다고 식별이 가능하다.
2) 기본타입의 값은 언제나 유효하나 박싱된 타입은 유효하지 않는 값 NULL을 가질 수 있다.
3) 기본타입이 박싱된 기본 타입보다 메모리, 시간 사용면에서 더 효율적이다.

> 다시 한 번 읽어보자.

### 사례를 살펴보며

Integer값의 오름차순으로 정렬하는 비교자다(복습해보자. 비교자의 compare 메서드는 첫번째 원소가 두번째 원소보다 작으면 음수(-), 같으면 0, 크면 양수(+)를 반환한다)

Integer는 그 자체로 순서가 있으니 이 비교자가 실질적인 의미는 없지만 아주 흥미로운 점을 보여준다.

```java
import java.util.Comparator;
public class ComparatorTest {
	public static void main(String[] args) {
		Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i ==j ? 0 : 1);
		int result = naturalOrder.compare(new Integer(42), new Integer(42));		
		System.out.println(result);
	}
}
```

별 다른 문제는 찾이 어렵고, 실제로 이것저것 테스트 해봐도 잘 통과한다. 예컨데 Collections.sort에 원소 백만 개짜리 리스트와 이 비교자를 넣어 돌려도 아무 문제가 없다. 리스트에 중복이 있어도 상관없다. 하지만 심각한 문제가 있는데 naturalOrder.compare(new Integer(42), new Integer(42)) 다.

두 인스턴스의 값이 42로 같으니 0을 출력해야 하지만 1을 출력한다. 즉, 첫번째 42가 두번째 42보다 크다고 주장한다.

원인이 뭘까?

naturalOrder의 첫번째 검사(i < j)는 잘 동작한다. 여기서 i와 j가 참조하는 오토박싱된 Integer인스턴스는 기본 타입 값으로 변환된다.
그런다음 첫 번째 정숫값이 두 번째 값보다 작은지 평가한다. 만약 작지 않다면 두 번째 검사(i == j)가 이뤄진다. 그런데 이 두번째 검사에서는 두 '객체 참조'의 식별성을 검사한다. i와 j가 서로 다른 Integer 인스턴스라면 이 비교의 결과는 false가 되고, 비교자는 1을 반환한다.

즉, 첫 번째 Integer 값이 두 번째보다 크다는 것이다. 이처럼 박싱된 기본 타입에 == 연산을 적용하면 오류가 일어난다.

### 실무에서 기본타입을 다루는 비교자가 필요하다면?

Comparator.naturalOrder를 사용하자. 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다. 그렇더라도 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다. 이렇게 하면 오류의 원인인 식별성 검사가 이뤄지지 않는다.

### 기이하게 동작하는 프로그램

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if(i == 42) {
            System.out.println("믿을 수 없군!");
        }
    }
}
```

NullPointerException이 발생한다. 원인은 i가 int가 아닌 Integer이며, 다른 참조타입 필드와 마찬가지로 i도 초기값이 null인데 있다.

**기본 타입과 박싱된 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다**
> 중요하다. 기억하자.

### 끔찍하게 느린 Long

```java
public static void main(String[] args) {
    Long sum = 0L;
    for(long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

이 프로그램은 실수로 지역변수 sumㅇ을 박싱된 기본타입ㅇ으로 선언해 느려졌다. 오류나 경고 없이 컴파일은 되나, 박싱과 언박싱이 반복해 일어나 체감될 정도로 성능이 느려진다.

### 기본 타입과 박싱된 기본타입의 차이를 무시한 대가는 어마무시하다. 그렇다면 박싱타입은 언제 써야할까?

1) 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 사용해야한다.

더 일반화하면, 매개변수화 타입이나 매개변수화 메서드(5장)의 타입 매개변수로는 박싱된 기본타입을 써야한다. 자바 언어가 타입 매개변수로 기본타입을 지원하지 않기 때문이다.
> 제네릭에서 타입매개변수로 박싱된 기본타입을 넣으라는 말로 쉽게 이해하라는 것 같음.

예컨데 변수를 `ThreadLocal<int>` 타입으로 선언하는 건 불가능하며 대신 `Thread<Integer>`를 써야한다. 마지막으로 리플렉션(아이템 65)를 통해 메서드를 호출할 때도 박싱된 기본타입을 사용해야한다.

### 정리

1) 기본 타입과 박싱된 기본타입 중 하나를 선택해야한다면 기본타입을 사용하라
2) 기본타입과 박싱된 기본타입의 차이는 어마무시하다. 차이점을 기억하라
    - 기본타입과 달리 박싱된 기본타입은 값과 식별성을 가지고 있다.
    - 박싱된 기본타입은 초기값이 null이다. nullPointerException이 발생하지 않도록 유념하자.
    - 기본타입이 박싱된 기본타입보다 성능, 시간면에서 효율적이다.

3) 기본 타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본타입의 박싱이 자동으로 풀린다.

