## 다른 타입이 적절하다면 문자열 사용을 피하라

문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.
그런데 문제열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않은 용도로 쓰이는 경향이 있다. 이번 아이템에서는 문자열을 쓰지 않아야 할 사례를 다룬다.
> 문자열이 편하긴 한 것 같다. 다만 문자열을 쓴다는 건 메모리에서 사용하는 크기가 크다는 것도 좀 알고 가면 좋겠다. <br>
> 영어 1byte, 한글 2byte / UTF-8 3byte

**문자열은 다른 값 타입을 대신하기에 적합하지 않다.** 많은 사람이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때, 주로 문자열을 사용한다.

사뭇 자연스러워 보이지만 입력받을 데이터가 진짜 문자열일 때만 그렇게 하는게 좋다. 받은 데이터가 수치형이라면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야한다.

예/아니오는 Boolean으로 변환

일반화해 이야기하면, 기본 타입이든 참조타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 하나 새로 작성하라.

**문자열은 열거타입을 대신하기에 적합하지 않다** 상수를 열거할 때는 문자열보다 열거 타입이 월능히 낫다. (아이템34)
> 열거타입을 사용하면 애플리케이션 실행과정에서 딱 한번 만들어지므로 메모리에 있어서도 이득이다. 뿐만아니라 MagicNumber와 같이 예상치 못한 변수의 사용이 사라진다. 일관성있는 타입을 이용할 수 있다고 생각한다.

**문자열은 혼합 타입을 대신하기에 적합하지 않다** 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지않은 생각이다. 예를들어 다음은 실제 시스템에서 가져온 코드다.

```java
String compoundKey = className + "#" + i.next();
```

이는 단점이 많은 방식이다. 혹여라도 두 요소중 구분해주는 문자 #이 두 요소중 하나에서 쓰였다면 혼란스러운 결과를 초래한다. 각 요소를 개별로 접근하려면 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 커진다.
> 공감한다. 이와 비슷하게 임시멤버에 대한 처리과정에서 ID를 여러가지를 준다고 쳐보자 _temp, _tmp, _bot 등을 String으로 연결해주는 것보다 class를 만들어 별도로 타입을 관리하는게 더 나은 선택같다.

적절한 equals, toString, compareTo 메서드를 제공할 수 없으며 String이 제공하는 기능에만 의존해야한다. 차라리 전용 클래스를 새로 만드는 편이 낫다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다(아이템24)

**문자열은 권한을 표기하기에 적합하지 않다** 권한을 문자열로 표현하는 경우가 종종있다. 예를들어 스레드 지역변수 기능을 설계한다고 해보자. 그 이름처럼 각 스레드가 자신만의 변수를 갖게 해주는 기능이다. 자바가 이 기능을 지원하기 시작한건 자바 2부터로

그 전에는 프로그래머가 직접 구현해야했다. 그 당시 이 기능을 설계해야 했던 여러 프로그래머가 독립적으로 방법을 모색하다가 종국에는 똑같은 설계에 이르렀다. 바로 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별한 것이다.

```java
public class ThreadLocal {
    private ThreadLocal() {}
    public static void set(String key, Object value);
    public static Object get(String key);
}
```

이 방식의 문제는 스레드 구분용 문자열 키가 전역 이름공간에서 공유된다는 점이다. 이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야한다. 만약 두 클라이언트가 서로 소통하지못해 같은 키를 쓰기로 결정한다면 의도치 않게 변수를 공유하게 된다.

결국 두 클라이언트 모두 제대로 기능하지 못할 것이다. 보안도 취약하다. 악의적인 클라이언트라면 의도적으로 같은 키를 사용해 다른 클라이언트의 값을 가져올 수 있다.

이 API는 문자열 대신 위조할 수 없는 키를 사용하면 된다. 이 키를 권한(capacity)이라고도 한다.
> 좀 난해하다.

```java
public class ThreadLocal {
    private ThreadLocal() {}
    public static class Key {
        Key() {}
    }
    public static Key getKey() {
        return new Key();
    }
    public static void set(Key key, Object value);
    public static void get(Key key);
}
```

이 방법은 앞서의 문자열 기반 API의 문제 2가지를 모두 해결해주지만, 개선의 여지가 있다. set과 get은 이제 정적 메서드일 이유가 없으니 Key 클래스의 인스턴스 메서드로 바꾸자. 이렇게 하면 더이상 Key는 스레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 스레드 지역변수가 된다.

결과적으로 지금의 톱레벨 클래스 ThreadLocal은 별달리 하는 일이 없어지므로 치워버리고, 중첩 클래스 Key의 이름을 ThreadLocal로 바꾸자.

```java
public final class ThreadLocal {
    public ThreadLocal();
    public void set(Object value);
    public Object get();
}
```
이 API에서 얻은 Object를 실제 타입으로 형변환 해야해서 타입안전하지 않다. 처음의 문자열 기반 API는 타입안전하게 만들 수 없으며, key를 사용한 API도 타입안전하게 만들기 어렵다. 매개변수화 타입으로 선언하면 간단하게 문제가 해결된다.

```java
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

이제 자바의 java.lang.ThreadLocal과 흡사해졌다. 문자열 기반 API의 문제를 해결해주며, 키 기반 API 보다 빠르고 우아하다.

### 정리

더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리치자. 문자열은 잘못 사용하면 번거롭고, 오류 가능성도 크다. 문자열을 잘못 처리하는 흔한 예로는 기본타입, 열거타입, 혼합타입이 있다.