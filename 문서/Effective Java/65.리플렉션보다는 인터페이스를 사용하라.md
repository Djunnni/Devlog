## 리플렉션보다는 인터페이스를 사용하라

리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다. Class객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.

나아가 Constructor, Method, Field 인스턴스를 이용해 각각의 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있다.

이 인스턴스들을 통해 해당 클래스의 인스턴스를 생성하거나 메서드를 호출하거나, 필드에 접근할 수 있다는 의미다.

예를들면 Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해준다. 리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데, 물론 단점이 있다.

1) 컴파일 타임 타입검사가 주는 이점을 하나도 누릴 수 없다.
    - 예외 검사도 마찬가지다. 프로그램이 리플렉션 기능을 써서 존재하지 않는 혹을 접근할 수 없는 메서드를 호출하려 시도하면 런타임 오류가 발생한다.

2) 리플렉션을 이용하면 코드가 지전분해지고 장황해진다. 지루한 일이고 읽기도 어렵다.

3) 성능이 떨어진다. 
    - 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다. 고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵지만, 내 컴퓨터에서 입력매개변수도 없고 int를 반환하는 메서드로 실험해보니 11배나 느렸다.

코드 분석 도구나 의존관계 주입 프레임워크처럼 리플렉션을 써야 하는 복잡한 애플리케이션이 몇가지 있다.

이런 도구들마저 리플렉션 사용을 점차 줄이고 있다. 단점이 명확하기 때문이다. 

**리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.**

컴파일 타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일 타입이더라도 적절한 인터페이스나 상위클래스를 이용할 수 있는 것이다. 다행히 이러한 경우라면 

**리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위객체를 참조해 사용하자.**



