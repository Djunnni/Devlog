
### 2. OCP(Open-Close Principle)

| OCP는 함수, 클래스, 모듈 등 구현할 때, 확장에 대해서는 개방적인 반면, 변경에 대해서는 폐쇄적이다.

이게 무슨 말일까?

#### OCP 예시 1번

Employee -> EmployeeDB -> MySQL

이런 3가지 클래스가 있다. EmployDB는 Employee를 이용해 MySQL로 저장/수정/삭제가 가능하다.

어느날 우린 데이터베이스를 MongoDB로 쓰고 싶다. 그러면 EmployeeDB를 interface로 분리하고 이미 정의된 기능을 Persistance에 따라서 재정의(오버라이딩)을 하게 될 것이다.

이 상황이 OCP를 설명해준다. 

더 와닿지 않는다면 한가지 예시가 더 있다.

#### OCP 예시 2번

이번에는 EmployeeDB를 테스트하고 싶다. 그런데 우리는 Mocking을 통해서 실제로 데이터베이스에 값이 반영되는걸 피하고 싶다.

하지만 EmployeeDB가 클래스로 구성되어 있다면 수정 또는 재작성을 통해 Employee를 다른곳에서 수정할 수 있는 상황이 발생하게 된다.

EmployeeDB가 interface라면? Mocking 시, 필요한 부분을 재정의해서 쓰면 된다.

이게 전부다.


#### OCP를 작성할 때, 어떤 부분을 고려해야 할까?

데이터를 관리하는 부분과 API 처리부분(ex, GUI 관리부분)을 구분지어 생각해 볼 필요가 있다.

#### 관련해서 TestCase를 작성할 때 나오는 [분로 단위 테스팅 기법] 이란?

OCP원칙을 지켜 Mocking의 경우도 가능하지만 Self-Shunt Test 기법도 가능하다.

Shunt는 `빗겨가다/회피하다/분로`의 뜻을 가지고 있고 Self는 말그대로 자기자신이다.

즉, 자기 자신을 테스트할 수 있는 환경이 가능해진다라고 받아드리면 좋다.

Mocking은 3자 느낌처럼 불러다가 맞는지 틀린지 확인하지만 자기자신을 테스트한다면 필드가 정확한 데이터가 있는지 확인이 더 명확해보인다.

예시를 들어 살펴보자.

#### 시나리오

Devday 프로젝트에서 사용할만한 사례로 이야기 해보겠다.

[작성중]