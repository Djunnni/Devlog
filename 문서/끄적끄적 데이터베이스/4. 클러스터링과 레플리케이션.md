# 4. 클러스터링과 레플리케이션

클러스터링과 레플리케이션이 필요한 이유는 장애복구애 초점이 잡혀있다고 생각한다.

### 클러스터링

동일한 구조를 가진 서버를 여러대로 관리해 데이터의 동기화를 관리한다.

- 장점
    - 노드간 데이터가 동기화되어 일관성을 유지한다.
    - 하나의 노드가 죽어도 장애없이 운영이 가능하다.
- 단점
    - 동기화에 대해 시간이 필요하다. Replica 보다 쓰기 성능이 떨어진다.
    - 장애가 전파됐을 때, 처리가 어려우며, 데이터 동기화로인해 스케일링에 한계가 있다.


### 레플리케이션

Master - Slave 구조로 보통 1:2 구조를 가지는 편인걸로 보인다.

두 계층간에 데이터가 일치하는지 무결성 검사가 이루어지지 않는 비동기 방식으로 업데이트 된다.

- 장점
    - DB 요청의 Read를 Slave에서 Write를 Master에서 관리하면 성능을 높일 수 있다.
    - 비동기 방식으로 운영되어 지연 시간이 거의 없다.

- 단점
    - 노드간의 데이터 동기화가 보장되지 않아 데이터를 얻지 못할 수도 있다.
    - Master가 다운되면 복구 및 대처가 까다롭다.

### 재대로 경험해보지 못한 레플리카 장애를 체험한다면 나는 어떻게 대처할 수 있을까?

이 상황에서는 write와 관련된 작업은 더이상 진행이 어렵게 된다.

1. 서비스에서 실패한 요청이 큐에 잘 적재되어 있는지 점검
2. 레플리카 중 일부를 Master로 전환이 가능한지 변경작업
3. 실패한 데이터 요청에 대해 큐에서 다시 재처리

### 파티셔닝, 샤딩과 클러스터링 레플리케이션의 차이점은?

클러스터링과 레플리케이션은 장애복구를 중점적으로 고려해 가용성을 키우는 방법을 다루며

파티셔닝과 샤딩은 성능의 향상과 자원관리를 통해 확장성을 키운 가용성을 다룬다.

### 참고

https://hudi.blog/mysql-replication-topology/

### PS

나중에 읽었을 때, 더 나은 방법과 대안이 있으면 고쳐보자. (2023-08-09)