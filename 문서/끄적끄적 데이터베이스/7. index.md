# 7. index

# 인덱스란?

인덱스는 쉽게 말하면 책의 색인 처럼 원하는 자료를 빠르게 찾아가기 위해 저장공간을 추가적으로 사용해 접근성을 높입니다.

인덱스를 사용하지 않는다면 전체 데이터를 처음부터 돌며 해당되는 튜플들을 찾아내게 됩니다. (FULL SCAN)

# 인덱스를 구성하는 알고리즘

1.HashTable
    - Key를 사용하여 필요한 자료에 빠르게 접근하는 알고리즘
    - O(1)의 시간복잡도를 갖음
    - Key, Value 형태로 저장됨
> HashTable은 말그대로 '=' 에 더 적합한 케이스다. 그러기 때문에 range나 비교문이 들어가게 되면 결국에는 모든 데이터에 접근해야 하게 된다.

2.B Tree
    - 이진탐색 트리의 일반화된 형태
    - 노드의 개수를 늘리고 트리의 전체 높이를 줄여 빠른 탐색속도를 유지
    - 리프노드가 모두 같은 레벨을 가지게 된다는 장점을 가지고 있어 balance-search-tree다.
> 선형탐색(O(N))과 달리 (O(logN))으로 탐색이 가능하다.

3.B+ Tree
    - B Tree를 개선시킨 구조다. MySQL(InnoDB)에서는 B+ Tree를 사용한다.
    - B+ Tree는 B트리와는 다르게 리프노드의 Key만 데이터 포인트를 가지고 있다.
    - 리프노드에서만 데이터 포인터가 존재해 노드에 더 많은 데이터를 보관할 수 있다. (중복된 키를 가질 수 있는 단점도 존재)

# 인덱스 만드는 법과 주의할 점

```sql
create index '인덱스 이름' on 'table명' ('index로 설정하고 싶은 컬럼')
```

인덱스는 위 명령어를 사용해 생성할 수 있습니다. 단, 저장공간을 추가적으로 사용하기 때문에 update나 delete가 빈번히 발생되는 컬럼은 최대한 인덱스로 설정하시면 안됩니다.
> update나 delete가 빈번히 발생한다면 index는 해당 인덱스를 *사용하지 않음 처리만 하지 제거를 하지 않는다*고 합니다. 그렇다면 인덱스는 쌓이게 되고 비대해져 오히려 성능에 악영향을 미치게 됩니다.

# 인덱스를 수정하는 법

drop 후, create을 진행해야 한다.
> mysql 에서는 인덱스를 수정하는 명령어는 없지만 oracle은 있다. 참고할 것!

```sql
drop index 'index명' on 'table명'
create index 'index명' on 'table명' ('index로 설정하고 싶은 컬럼', ...)
```

# 클러스터드 인덱스와 비클러스터드 인덱스



# Table Full Scan과 Index Range Scan이 뭔지 알아보자

* Table Full Scan


* Index Range Scan