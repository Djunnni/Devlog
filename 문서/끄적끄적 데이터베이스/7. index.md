# 7. index

# 인덱스란?

인덱스는 쉽게 말하면 책의 색인 처럼 원하는 자료를 빠르게 찾아가기 위해 저장공간을 추가적으로 사용해 접근성을 높입니다.

인덱스를 사용하지 않는다면 전체 데이터를 처음부터 돌며 해당되는 튜플들을 찾아내게 됩니다. (FULL SCAN)

# 인덱스를 구성하는 알고리즘

1.HashTable
    - Key를 사용하여 필요한 자료에 빠르게 접근하는 알고리즘
    - O(1)의 시간복잡도를 갖음
    - Key, Value 형태로 저장됨
> HashTable은 말그대로 '=' 에 더 적합한 케이스다. 그러기 때문에 range나 비교문이 들어가게 되면 결국에는 모든 데이터에 접근해야 하게 된다.

2.B Tree
    - 이진탐색 트리의 일반화된 형태
    - 노드의 개수를 늘리고 트리의 전체 높이를 줄여 빠른 탐색속도를 유지
    - 리프노드가 모두 같은 레벨을 가지게 된다는 장점을 가지고 있어 balance-search-tree다.
> 선형탐색(O(N))과 달리 (O(logN))으로 탐색이 가능하다.

3.B+ Tree
    - B Tree를 개선시킨 구조다. MySQL(InnoDB)에서는 B+ Tree를 사용한다.
    - B+ Tree는 B트리와는 다르게 리프노드의 Key만 데이터 포인트를 가지고 있다.
    - 리프노드에서만 데이터 포인터가 존재해 노드에 더 많은 데이터를 보관할 수 있다. (중복된 키를 가질 수 있는 단점도 존재)

# 인덱스 확인하기

```sql
show index from '테이블 이름'
```

# 인덱스 만드는 법과 주의할 점

```sql
create index '인덱스 이름' on 'table명' ('index로 설정하고 싶은 컬럼')
alter table '테이블 명' add index '인덱스 이름'('index 컬럼')
```

인덱스는 위 명령어를 사용해 생성할 수 있습니다. 단, 저장공간을 추가적으로 사용하기 때문에 update나 delete가 빈번히 발생되는 컬럼은 최대한 인덱스로 설정하시면 안됩니다.
> update나 delete가 빈번히 발생한다면 index는 해당 인덱스를 *사용하지 않음 처리만 하지 제거를 하지 않는다*고 합니다. 그렇다면 인덱스는 쌓이게 되고 비대해져 오히려 성능에 악영향을 미치게 됩니다.

# 인덱스를 수정하는 법

drop 후, create을 진행해야 한다.
> mysql 에서는 인덱스를 수정하는 명령어는 없지만 oracle은 있다. 참고할 것!

```sql
drop index 'index명' on 'table명'
create index 'index명' on 'table명' ('index로 설정하고 싶은 컬럼', ...)
```

# [사전지식] Page와 Extent

데이터는 8KB 단위 블럭으로 저장이되는데 이를 Page라고 부르고 있습니다. 1MB에는 128page가 저장이 가능합니다. 하나의 Row는 여러개의 Page에 걸쳐 저장될 수 없고 단 하나의 Page에만 저장될 수 있습니다.

하나의 Row의 최대 사이즈는 8 * 1024로 8192kb이지만 정보를 저장하기위한 공간이 들어 최대크기는 8060kb입니다.

Extent는 8개의 연속된 페이지를 의미하며 1Page가 8KB이므로 1Extent는 64KB입니다.

그 밖의 인덱스에 대해 더 알고싶으면 여기를 살펴보자.

- https://dongwooklee96.github.io/post/2021/12/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%8F-%EB%A0%88%EC%BD%94%EB%93%9C-%EA%B5%AC%EC%A1%B0.html

# 클러스터드 인덱스와 비클러스터드 인덱스

## 클러스터드 인덱스란?

테이블 전체가 정렬된 인덱스가 되는 방식, 데이터와 함께 전체 테이블이 물리적으로 정렬된다.

클러스터형 인덱스는 테이블당 하나만 생성이 가능하다. 특정 컬럼을 PK로 지정하면 클러스터형 인덱스를 생성한다.

또는 Unique + Not Null로 지정해도 클러스터형 인덱스를 생성한다. 만약 PK와 Unique + Not Null을 모두 가지고 있다면 PK를 우선적으로 클러스터형 인덱스를 생성한다.

만약 둘다 없다면 InnoDB는 내부적으로 GEN_CLUST_INDEX 컬럼을 통해 클러스터형 인덱스를 생성한다.

클러스터드 인덱스는 B+ Tree처럼 루트페이지에서는 다른 페이지로의 포인터가 있고 리프 페이지에서는 Key를 통해 데이터를 조회할 수 있다.

## 비클러스터드 인덱스란?

보조 인덱스라고도 불리며 물리적으로 테이블을 정렬하지 않는다. 별도로 정의된 인덱스 페이지를 생성하고 관리한다. 실제 데이터를 함께 가지고 있지 않다.
> 인덱스 페이지와 데이터 페이지가 분리되어 있음. 리프 페이지는 `데이터 페이지 번호 + #오프셋`으로 가지고 있어 인덱스 페이지에서 데이터 페이지로 이동하는 하나의 과정이 추가됨

비 클러스터드 인덱스는 여러개 생성이 가능하다. 

자세히는 여기서 보자 https://hudi.blog/db-clustered-and-non-clustered-index/

# Table Full Scan과 Index Range Scan이 뭔지 알아보자

* Table Full Scan


* Index Range Scan

# 참고
- https://hudi.blog/db-index-and-indexing-algorithms/
- https://mangkyu.tistory.com/96