* JVM Garbage Collection 동작 과정
    * JVM의 가비지 컬랙션은 내부적으로 Young 영역, Old 영역이 있다. 두 영역에 따라 동작과정은 달라지지만 공통적인 작업은 2가지로 동일합니다.1. Stop the World2. Mark and Sweep Stop the World는 JVM이 가비지 컬랙션을 실행하기 위해 어플리케이션 실행을 멈추는 작업이다. GC를 실행하는 쓰레드를 제외한 나머지 작업이 중단되어 있습니다.이 때, Mark And Sweep을 통해 사용하고 있는 메모리와 아닌 영역을 Mark하고 Mark되지 않은 영역은 메모리 반환이 일어납니다.https://mangkyu.tistory.com/118
* Garbage Collection이 필요한 이유
    * 가비지 컬렉션이 필요한 이유는 메모리를 자동화해 개발자가 직접 메모리를 관리하지 않아도 되기 때문입니다. C, C++의 경우 직접 메모리를 할당, 해제하지만 Java의 경우 가비지 컬렉션을 통해 직접 메모리를 해제하는 일이 없습니다. 그렇기에 시스템이 메모리의 상황을 추적한 뒤 더이상 사용되지 않는다면 메모리를 비워주고 있습니다.이를 통해서 자동화 관리된다는 편의성과 직접 반환하지 않는데 잘못된 참조를 하지않아 안전성을 가지고 있습니다.
* 가비지 컬렉터 [위와 상동]
    * 단점을 더하자면 가비지 컬랙션은 오버헤드가 발생가능해 프로그램의 실행속도를 저하시킬 수 있다. 이를통해 메모리 사용이 중요하다면 가비지 컬랙션의 성능을 고려해야 한다.
* 프로그래머가 GC를 직접 다룰 수 있나요?
    * System.gc()를 통해 직접적으로 호출을 할 수 있지만 즉시실행은 보장하지 않습니다. 그 이유는 가비지컬랙션 정책과 JVM의 OS환경에 따라 모두 다르기 때문입니다.
* 그 외 GC를 다루는 방법에는 무엇이 있나요?
    * 잘 모르겠습니다.(MinorGC, MajorGC, SerialGC, ParallelGC 인지 모르겠음) 
* G1 GC가 무엇인지에 대해서 설명해주실 수 있나요?
    * 가비지 컬랙션의 알고리즘 중 하나로  메모리관리를 더 잘 해보자는 CMS GC 방법에서 CPU와 메모리를 더 소모하는 문제와 Stop The World가 길어지는 문제를 개선하고자 Java7부터 지원됐다고 알고 있습니다.
    * 기존 Heap 영역에서 Young, Old 영역을 나누어서 사용했다면 G1에서부터는 물리적으로 메모리 공간을 나누지 않고 Region의 개념으로 지역을 논리적으로 구분해 할당합니다.
	https://mangkyu.tistory.com/119

* G1 GC가 가지고 있는 특징에 대해서 말씀해주실 수 있으신가요?
    * G1은 Eden, Survivor, Old, Humonogous, Available/Unused 가 논리적으로 관리됩니다. Humonogous는 Region의 50% 크기를 초과하는 객체를 저장 Available/Unused는 사용되지않은 영역이다.
    * Heap을 동일한 크기의 Region으로 나누고 가비지가 많은 Region을 우선적으로 GC 실행한다.
* MinorGC는 한 지역에 객체를 할당하다가 꽉차면 다른 지역에 할당하고 Minor GC가 실행된다. 각 지역을 추적하고 있어 가비지가 많은 지역을 찾아 Mark and Sweep을 진행한다.
* MajorGC는 시스템이 운영되다가 객체가 너무 많아 빠르게 메모리를 회수할 수 없을 때 동작한다. G1은 기존 GC들과 달리 가비지가 어디에 많은 지 알고 있어 해당지역에만 GC를 발생할 수 있어 Concurrent하게 수행되어 지연을 최소화할 수 있다.
* Java9부터는 Default GC로 사용되고 있다.
